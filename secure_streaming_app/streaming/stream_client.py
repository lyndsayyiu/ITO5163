"""
stream_client.py

Handles the outgoing client side of the secure streaming channel:
- Connects to the server using TCP
- Performs the secure handshake (ECDH + RSA authenticiation)
- Derives the session key
- Sends encrypted messages using secure_send()

The messages are generated by the DataSource class and sent using AES-GCM encryption through secure_send().
"""
import socket
import json
import time

from handshake.ecdh import ECDHKeyPair
from handshake.identity import Identity
from handshake.rsa_auth import sign_ecdh_public_key, verify_ecdh_public_key_signature
from handshake.key_derivation import derive_session_key
from streaming.protocol import build_client_hello, parse_server_hello
from crypto.secure_channel import secure_send
from streaming.data_source import DataSource

def start_client(host: str, port: int, identity: Identity):
    """
    Connects to the server, performs a secure handshake and begins streaming encrypted messages generated by a DataSource instance.

    Arguments:
        host (str): The server's hostname or IP address.
        port (int): The server's TCP port. 
        identity (Identity): The client's RSA identity containing:
            - device_id
            - RSA public key
            - RSA private key
            - trust store of the public keys
    """
    print(f"[CLIENT] Connecting to server at {host}:{port} ...")

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    print("[CLIENT] Connected to server.")

    #Perform handshake -> Returns AES-GCM session key
    session_key = client_handshake(sock, identity)
    print(f"[CLIENT] Handshake complete. Session key established.")

    #Instantiate a data source to create sequential messages
    data_source = DataSource(start_seq=1)
    print(f"[CLIENT] Starting encrypted message stream...")
    #Initiate counter for channel sequence
    secure_seq = 1

    #Continuous streaming loop
    try:
        while True:
            #Generate next plaintext message (dict)
            plaintext_dict = data_source.next_message()

            #Encrypt and send using AES-GCM            
            secure_send(sock, session_key, secure_seq, plaintext_dict)
            print(f"[CLIENT] Sent message #{secure_seq}: {plaintext_dict}")

            secure_seq += 1
            time.sleep(1) #Control send rate (1 message per second)
    except KeyboardInterrupt:
        print("\n[CLIENT] Streaming stopped by user.")

    finally:
        sock.close()
        print("[CLIENT] Connection closed.")

#Handshake logic
def client_handshake(sock, identity: Identity) -> bytes:
    """
    Performs the secure handshake with the server. 

    Generates elliptic curve Diffie-Hellman key exchange key pair. 
    Signs the public key with the RSA private key and sends a client_hello message to server.
    Receives server_hello and verifies the server RSA signature.
    Computes the shared secret and derives symmetric AES-GCM session key using HKDF

    Arguments:
        sock: Opens TCP socket connected to server.
        identity (Identity): The client's RSA identity.

    Returns:
        bytes: A 32-byte session key suitable for AES-GCM.
    """ 

    # --- Generating ECDH key pair ---
    client_ecdh = ECDHKeyPair()
    client_pubkey_bytes = client_ecdh.public_bytes()

    # --- Signing ECDH public key with RSA private key ---
    signature = sign_ecdh_public_key(identity.private_key, client_pubkey_bytes)

    # --- Build and send client_hello ---
    client_hello = build_client_hello(identity.device_id, client_pubkey_bytes, signature)
    client_hello_json = json.dumps(client_hello).encode("utf-8")
    #Send to server
    sock.sendall(client_hello_json)
    print("[CLIENT] Sent client_hello message")

    # --- Receive server_hello ---
    raw_data = sock.recv(4096)
    if not raw_data:
        raise ConnectionError("[CLIENT] Failed to receive server_hello")
    
    try:
        server_hello_json = raw_data.decode("utf-8")
        server_hello = json.loads(server_hello_json)
    except Exception as e:
        raise ValueError(f"[CLIENT] Invalid server_hello format: {e}")

    print(f"[CLIENT] Received server_hello: {server_hello}")

    # --- Parse and verify server_hello ---
    try:
        server_device_id, server_pubkey_bytes, server_signature = parse_server_hello(server_hello)
    except Exception as e:
        raise ValueError(f"[CLIENT] Failed to parse server_hello: {e}")
    
    #Look up server's RSA public key from trust store
    server_rsa_key = identity.get_peer_public_key(server_device_id)

    #Verifying RSA signature over server's ECDH public key bytes
    is_valid = verify_ecdh_public_key_signature(server_rsa_key, server_pubkey_bytes, server_signature)

    if not is_valid:
        raise ValueError("[CLIENT] Invalid RSA signature on server's ECDH key")
    
    print("[CLIENT] Server RSA signature verified.")

    # --- Compute shared secret ---
    shared_secret = client_ecdh.compute_shared_secret(server_pubkey_bytes)

    # --- Derive session_key ---
    session_key = derive_session_key(shared_secret)
    print(f"[CLIENT] Derived session key ({len(session_key)} bytes)")

    return session_key