"""
stream_client.py

Handles the outgoing client side of the secure streaming channel:
- Connects to the server using TCP
- Performs the secure handshake (ECDH + RSA authenticiation)
- Derives the session key
- Sends encrypted messages using secure_send()

The messages are generated by the DataSource class and sent using AES-GCM encryption through secure_send().
"""
import socket
import json
import time
import sys

from handshake.ecdh import ECDHKeyPair
from handshake.identity import Identity
from handshake.rsa_auth import sign_ecdh_public_key, verify_ecdh_public_key_signature
from handshake.key_derivation import derive_session_key
from streaming.protocol import build_client_hello, parse_server_hello
from crypto.secure_channel import secure_send
from streaming.data_source import DataSource

def start_client(host: str, port: int, identity: Identity):
    """
    Connects to the server, performs a secure handshake and begins streaming encrypted messages generated by a DataSource instance.

    Arguments:
        host (str): The server's hostname or IP address.
        port (int): The server's TCP port. 
        identity (Identity): The client's RSA identity containing:
            - device_id
            - RSA public key
            - RSA private key
            - trust store of the public keys
    """
    #Creating TCP socket for connection
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    #Attempt to establish TCP conection to server
    try:
        sock.connect((host, port))
        print("[CLIENT] Connected to server.")
    except ConnectionRefusedError:
        print(f"[CLIENT ERROR] Connection refused. Is the server running at {host}:{port}?")
        sys.exit(1)
    except socket.timeout:
        print(f"[CLIENT ERROR] Connection timeout. Server at {host}:{port} is not responding.")
    except Exception as e:
        print(f"[CLIENT ERROR] Failed to connect to server: {e}")
        sys.exit(1)

    
    #Perform handshake -> Returns AES-GCM session key
    try:
        session_key = client_handshake(sock, identity)
        print(f"[CLIENT] Handshake complete. Session key established.")

    #If handhake fails
    except ValueError as e:
        #Cryptographic validation failure
        print()
        print("--- SECURITY ERROR - HANDSHAKE FAILED ---")
        print(f"[CLIENT ERROR] {e}")
        print("\nPossible causes:")
        print(" 1. Server sent invalid cryptographic material")
        print(" 2. Main-in-the-middle-attack detected")
        print(" 3. Server is using incompatible protocol version")
        print(" 4. Server's RSA signature verification failed")
        print("[CLIENT] Closing connection.")
        #Close socket and terminate program
        sock.close()
        sys.exit(1)
    
    except ConnectionError as e:
        #Network/Connection issues during handshake
        print("--- CONNECTION ERROR - HANDSHAKE FAILED ---")
        print(f"[CLIENT ERROR] {e}")
        print("\nPossible causes:")
        print("  1. Server disconnected during handshake")
        print("  2. Network issues interrupted the connection")
        print("  3. Server rejected the handshake")
        print("[CLIENT] Closing connection.")
        sock.close()
        sys.exit(1)

    #Instantiate a data source object to create sequential messages
    data_source = DataSource(1)
    print(f"[CLIENT] Starting encrypted message stream...")

    #Initiate counter for channel sequence
    secure_seq = 1

    #Continuous streaming loop
    try:
        while True:
            #Generate next plaintext message (dict)
            plaintext_dict = data_source.next_message()

            #Encrypt and send using AES-GCM            
            secure_send(sock, session_key, secure_seq, plaintext_dict)
            print(f"[CLIENT] Sent message #{secure_seq}: {plaintext_dict}")

            secure_seq += 1
            time.sleep(1) #Control send rate (1 message per second)

    except KeyboardInterrupt:
        print("\n[CLIENT] Streaming stopped by user.")

    except ValueError as e:
        print(f"\n[CLIENT ERROR] Message encryption/validation failed: {e}")
        print("This may indicate:")
        print("  - Session key corruption")
        print("  - Protocol violation")
        print("Connection will be closed.")

    except ConnectionError as e:
        # Network failure during streaming
        print(f"\n[CLIENT ERROR] Connection lost: {e}")
        print("Server may have disconnected or network issue occurred.")
    
    except Exception as e:
        # Unexpected error during streaming
        print(f"\n[CLIENT ERROR] Unexpected error during streaming: {e}")
        print(f"Error type: {type(e).__name__}")

    finally:
        sock.close()
        print("[CLIENT] Connection closed.")

#Handshake logic
def client_handshake(sock, identity: Identity) -> bytes:
    """
    Performs the secure handshake with the server. 

    Generates elliptic curve Diffie-Hellman key exchange key pair. 
    Signs the public key with the RSA private key and sends a client_hello message to server.
    Receives server_hello and verifies the server RSA signature.
    Computes the shared secret and derives symmetric AES-GCM session key using HKDF

    Arguments:
        sock: Opens TCP socket connected to server.
        identity (Identity): The client's RSA identity.

    Returns:
        bytes: A 32-byte session key suitable for AES-GCM.

    Raises:
        ValueError: If cryptographic validation fails (invalid keys, signatures, etc.)
        ConnectionError: If network/connection issues occur
    """ 

    # --- Generating ECDH key pair ---
    #Ephemeral ECDH keys are created each session to provide forward secrecy
    client_ecdh = ECDHKeyPair()
    client_pubkey_bytes = client_ecdh.public_bytes()

    # --- Signing ECDH public key with RSA private key ---
    signature = sign_ecdh_public_key(identity.private_key, client_pubkey_bytes)

    # --- Build and send client_hello ---
    client_hello = build_client_hello(identity.device_id, client_pubkey_bytes, signature)
    #Send to server over TCP
    sock.sendall(client_hello.encode("utf-8"))
    print("[CLIENT] Sent client_hello message")

    # --- Receive server_hello ---
    # Wait for server's response containing their ECDH key + signature
    raw_data = sock.recv(4096)
    if not raw_data:
        raise ConnectionError("[CLIENT] Failed to receive server_hello")
    
    #Decode and parse the JSON response from the server
    try:
        server_hello_json = raw_data.decode("utf-8")
        server_hello = json.loads(server_hello_json)
    except Exception as e:
        raise ValueError(f"[CLIENT] Invalid server_hello format: {e}")

    print(f"[CLIENT] Received server_hello: {server_hello}")

    # --- Parse and verify server_hello ---
    #Extract server's device_id, ECDH public key and RSA signature
    try:
        server_device_id, server_pubkey_bytes, server_signature = parse_server_hello(server_hello_json)
    except Exception as e:
        raise ValueError(f"[CLIENT] Failed to parse server_hello: {e}")
    
    #Look up server's RSA public key from our trust store
    server_rsa_key = identity.get_peer_public_key(server_device_id)

    #Verifying that the server's ECDH key was signed by their legitimate RSA private key
    #Authenticates server and prevent man-in-the-middle attacks
    is_valid = verify_ecdh_public_key_signature(server_rsa_key, server_pubkey_bytes, server_signature)

    if not is_valid:
        raise ValueError("[CLIENT] Invalid RSA signature on server's ECDH key")
    
    print("[CLIENT] Server RSA signature verified.")

    # --- Compute shared secret ---
    shared_secret = client_ecdh.compute_shared_secret(server_pubkey_bytes)

    # --- Derive session_key ---
    #Using HKDF to derive a AES-256 key from the shared secret
    #Key derivation ensures uniform randomness
    session_key = derive_session_key(shared_secret)
    print(f"[CLIENT] Derived session key ({len(session_key)} bytes)")

    return session_key